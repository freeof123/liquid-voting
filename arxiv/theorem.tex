\section{Theorem}
In this section we prove some properties of our algorithm. We first analyze our protocol for constructing the delegate graph.
\begin{lemma}
   If a voter's delegate operation does not generate a cycle of the delegate graph (locally checked), then the corresponding edge will never be deleted. 
\end{lemma}
\begin{proof}
	Assume by contradiction that the delegate edge is deleted. By definition, there must be a cycle such that the delegate edge is the latest, which means that the cycle are generated by the appearance of the delegate edge, contradiction.
\end{proof}
It means that, if the voter follows the protocol, then his delegation are garanteed to be retained, which is benefit for him. Otherwise if he deviates (his delegation generates a cycle), his delegation may be deleted. (It is also possible to be retained, if other voters further change their delegate and remove the cycle)
\begin{lemma}
	If a voter deviates from our mechanism, by sending a delegate edge that generates a cycle, then further, this edge will not cause other voter's delegate edge to be refused if they follows the protocol.
\end{lemma}
\begin{proof}
	We call the delegate edge of the dishonest voter edge $A$. We prove that, if an edge $B$ is refused with the existence of edge $A$, then it will also be refused without the existence of edge $A$.
	
	Since $B$ is refused, it lies on a cycle which contains $A$. Since $A$ also lies on another cycle, if $A$ is delete, $B$ still lies on a cycle, and should be refused according to the protocol. The lemma is proved.
\end{proof}
The lemma shows that, even if a voter deviates from the protocol, other voters are not influenced. 

There are also sublinear-time algorithms that can judge whether a cycle is generated for a incoming delegate edge, which can be used in smart contract. However it is more complex and require more gas fee for each delegate massage. So still our protocol is recommended in practice. 

Next, we introduce our main theorem:
\begin{theorem}
	For each voting massage in liquid democracy problem, the voting status can be updated and displayed within $O(\log n)$ time complexity. Moreover, our algorithm can be deploy on the Ethereum mainnet and overcome the gas limitation, for the number of voters more than one million.
\end{theorem}
The theorem is obvious according to the properties of the tools we used. Here we illustrate some issues.
\begin{itemize}
	\item Processing a voter's voting message does not rely on the initialization data of other voters that has not voted, since our algorithm only requires the data from the nearest voted parent.
	\item The ``mapping" structure in Solidity (the coding language of Ethereum smart contract) satisfies that, the storages are allocated only if they are assigned values. For example, the storage $lazy[3]$ can be allocated without the allocation of $lazy[1]$ and $lazy[2]$. Moreover, $lazy[1]$ and $lazy[2]$ still can be visit but always returned a default value 0, which is just the requirement of our algorithm.
	\item The time complexity of update operation in interval tree is $O(\log n)$, since at each level of the interval tree, at most two intervals are at the recursive state: except for the interval tree root, there are at least one endpoints of the interval to be update are the same as the endpoints of the interval of current node. So at the next level, either there are only one interval to be executed, or there are two intervals, but one of them is identical to the interval of the next interval tree node, and the recursion ends. 
\end{itemize}
For the part of Ethereum, we leave the proof in the experiment section.