\section{Introduction}
Democracy has always been a widely concerned topic. Voting, as a primary method for realizing democracy in modern society, is more and more common in practice, with applications ranging from the presidential election to community governance \cite{gerber1998primary,kohno2004analysis}. Meanwhile, various issues emerge due to the current voting system, with low participation \cite{birch2016full,kousser2007does} and black-box operation\cite{bannet2004hack,harris2004black}\footnote{According to \cite{harris2004black} Black Box Voting is: ``Any voting system in which the mechanism for recording and/or tabulating the vote is hidden from the voter, and/or the mechanism lacks a tangible record of the vote cast"} to be two of the most significant. Now, a group of technologist are looking for a new approach to reform the voting system, bring all people with voting rights closer to their representatives and holding elections in a public, verifiable way. In other words, voters should exercise their rights in every related voting, e.g. a policy issue or a piece of new legislation, in which the voting status should be publicly displayed and traceable. However, usually people do not have time for full participation, or they are not expert with respect to the area involved by the voting proposal, which resulted in a large number of voting powers not actually being exercised.

The concept liquid democracy (also known as proxy voting, delegate voting) is proposed to handle the participation issue, in which the core idea is that, each voter (also called delegator) can select a personal representative who has the authority to be a proxy (also called delegate) for his vote.  Those delegates can further proxy their votes to other people, creating a directed network graph (called delegate graph). Whenever a delegate votes to a candidate (or a proposal, a policy), by default all his delegators' (including multi-level) voting powers are also cast to that candidate. If the delegator dislikes the way in which the proxy voted, they can either vote themselves, which dilutes the proxy's power, or pick another delegate for the next vote. Applying liquid democracy system significantly reduces time costs of voters and increases voting participation, which has been studied over a long period of time.

The early proposal about liquid democracy can be traced back to 1884 by Lewis Carroll \cite{carroll1884principles}, and followed by a number of economists \cite{william1912primary,miller1969program,paulin2014through}. Nowadays, many companies/parties also implement practical applications of liquid democracy, such as Google votes \cite{hardt2015google}, Pirate Parties (software: liquid feedback) \cite{behrens2014principles}, etc. However, they are still centralized organization, where black-box operation and statistical error are inevitable.

The introduction of blockchain \cite{nakamoto2008bitcoin} and on-chain smart contract technology \cite{wood2014ethereum} satisfies the openess and transparency requirement of voting system. Generally speaking, a blockchain is a decentralized and immutable public ledger ensured by cryptography and P2P networking, storing data including transaction information which is observerble by any user. The smart contract is a pre-designed instruction set for storing and operating on-chain data, led by Ethereum. The source code of the voting system can be deployed on the Ethereum mainnet through smart contract and invoked through on-chain transactions. %where each voter can obtain the voting status and check the availability from etherscan\footnote{etherscan.io} or other Ethereum nodes. 
The decentralization of blockchain gurantees that the voting system are impartially executed without any need of trusted third party, eradicating black-box operations.

 A fundamental requirement of on-chain voting systems is realtime self-tallying, which states that, for each incoming voting message,  the contract itself can record ballots\footnote{We uses ballot to denote the number votes that a candidate receives.} and update the voting status (and display it). The self-tallying property skips the trouble to download the whole Ethereum data (and use it to off-chain compute the results, mainly for those who do not participate the voting), or to collect majorityâ€™s signatures confirming a specific voting status.\footnote{With the self-tallying property, users can visits the variables of a smart contract by simply send RPC requests to Ethereum full nodes. Otherwise, without the support of any centralized parties like {\em etherscan.io}, users need to download the full Ethereum in order to obtain historical visiting data of the smart contract (current size more than 3.4TB).}

However, the main challenge for realizing on-chain liquid democracy is the limitation of gas fee on Ethereum mainnet, which is remain open\footnote{https://forum.aragon.org/t/open-challenges-for-on-chain-liquid-democracy/161}: executing a single instruction of smart contracts consumes a certain amount of gas, called gas fee, with the average about 10 thousand\footnote{According to https://github.com/ethereum/EIPs/blob/master/EIPS/eip-150.md, one storage\_modify instruction costs 5000 gas, and one storage\_add instruction costs 20000 gas.}.  Whereas Ethereum has a parameter \textbf{block\_gas\_limit}, usually about 10 million, which determines the total gas that can be consumed within a block. That is, the total gas fee for invoking a smart contract can not exceed block\_gas\_limit, because the corresponding transaction can only be included in one block, which means that number of instructions can not exceed 10 million/10 thousand = 1000, otherwise the transaction will be refused. 

 The difficulty lies in the computation of two pieces of critical information upon receiving a voting massage: i) the actual voting power that the voter exercises, which would be reduced since some of his delegators may already cast a direct vote, and ii) the change other candidates' ballots, since the voter's direct vote also reduces the actual voting power of his delegate. Naive algorithms usually compute the two values by traversing through the delegate graph, of which the on-chain time complexity is $O(n)$ for processing each voting message, where $n$ is the number of voters. Especially, when the delegate graph is chain-like, they are undesirable due to the limitation of gas fee, since application scenarios are limited to less than one thousand voters (usually votings with millions of voters are required)

Some discussions try to solve the challenge by add restrictions to the delegate graph, i.e., only allow the delegate graph with the max-depth less than 100. This modification essentially limits voters' behavior, which is lack of user friendliness and does not catch the core of democracy. Moreover, this method is vulnerable under attack: suppose Bob wants to prevent Alice from delegating to anyone, he can create 98 accounts and form a delegate chain, with the top node of the chain delegating to Alice. (Creating new accounts is zero-cost in Ethereum) Anytime Alice delegates to a node, a 100-depth chain is generated, thus the delegation will be refused. Other solutions abound but all unreasonable when meet with the gas fee limitation. 

In this paper we propose an algorithm that reduces the on-chain time complexity to $O(\log n)$ for processing each voting information, which essentially solves the on-chain liquid democracy problem. Our algorithm does not add any restriction to voters: any voters can delegate arbitrary. Our algorithm's off-chain time complexity is also acceptable, only $O(n)$. 

Our algorithm mainly depends on two techniques, the Merkel tree, an on-chain storage method, and the interval tree, a data structure. Our algorithm solves the liquid democracy  problem with the following aspect: 
\begin{itemize}
\item At the beginning of a voting, each voter obtains the delegate graph by snapshotting the current height of Ethereum, then executes a $O(n)$ off-chain initialization to get his initialization data.  
\item  Each voter is not allowed to change his delegate within the period of a voting, but he can directly vote to a candidate by send a voting massage, attached with his initiation data. The Merkel tree method checks the correctness of the initiation data with $O(\log n)$ time complexity. 
\item Upon receiving a voting message, our algorithm requires $O(\log n)$ time complexity for updating/displaying the voting status and storage, through the interval tree structure. 
\end{itemize}

Our on-chain algorithm excluding the Merkel tree part also enhances the off-chain liquid democracy: if each voter votes once, then the time complexity is $O(n^2)$ for traversal algorithms, while our algorithm is $O(n\log n)$. We focus on the on-chain situation in the following of this paper. 
